#include <iostream>  // cout
#include <cstdio>    // printf

int main() {

    // До этого мы работали с автоматическим выделением и освобождением памяти

    {  // область видимости, scope

        // происходит автоматическое выделение памяти под переменные и статические массивы в области видимости
        int var = 0;
        int arr[2] = {};

        // при выходе из области видимости память автоматически высвобождается
    }

    // здесь, у нас уже нет переменной 'var' и массива 'arr'
    // участки памяти, выделенные под переменную и массив свободны для дальнейшего использования

    // память для массивов фиксированного размера и обычных переменных
    // выделяется из специального резервуара памяти - стека;
    // стек имеет довольно ограниченный объем

    {
//        int arr[1000000];  // 1 млрд. int-ов = 4 млрд. байтов памяти (стек такое не вместит)
        // программа завершится с ошибкой
    }

    // проблема нехватки памяти на стеке решается при помощи динамической памяти;
    // динамическое выделение памяти - способ запроса памяти из операционной системы,
    // такая память выделяется из другого гораздо более объемного источника - кучи (heap)

    {
        // запросим выделение памяти для хранения целочисленного типа int
        // оператор new возвращает указатель, содержащий адрес выделенной памяти
        int *pointer = new int{0};  // инициализируем значение переменной нулем

        // для доступа (чтение, запись, удаление) к выделенной памяти используется указатель
        *pointer = 3;

        printf("Heap int variable's address: %X, value: %d\n", pointer, *pointer);

        // Стоит отметить, что указатель лежит на стеке, а не в куче,
        // т.е. после выхода из области видимости (scope) переменная-указатель
        // автоматически удалится из памяти, а вот данные на которые указатель ссылался - нет.
        // Поэтому, необходимо вручную освободить выделенный участок памяти при помощи оператора delete,
        // до выхода из области видимости указателя.

        delete /* указатель */ pointer;

        // даже если мы высвободили участок памяти (теперь он не в нашем владении)
        // требуется обнулить указатель, так как он все еще хранит в себе адрес высвобожденного участка памяти

        /*
         // попытка получить доступ к участку памяти, больше не принадлежащего нашей программе
         if (pointer != nullptr) {
            *pointer = 1;  // сработает и приведет к непредсказуемым результатам
         }

         // или попытка высвободить память повторно
         delete pointer;  // непредсказуемые результаты (скорее всего ошибка и завершение программы)
        */

        pointer = nullptr;  // обнуляем указатель

        if (pointer != nullptr) {  // уже не сработает
            *pointer = 1;
        }

        // оператор delete ничего не делает при работе с нулевыми указателями
        delete pointer;  // ничего не сделает
    }

    {
        // выделили память из кучи и не высвобождаем ее
        int *int_pointer = new int{0};
    }
    // приводит к утечке памяти - программа владеет участком памяти, адреса к которой у нас уже нет

    return 0;
}