#include <iostream>  // cout
#include <cstdio>    // printf

int main() {

    // до этого мы работали с автоматическим выделением и освобождением памяти

    {  // область видимости, scope

        // происходит автоматическое выделение памяти под переменные и статические массивы
        int var = 0;
        int arr[2] = {};

        // при выходе из блока память автоматически высвобождается
    }

    // здесь, у нас уже нет переменной 'var' и массива 'arr'
    // участки памяти, выделенные под переменную и массив свободны для дальнейшего использования

    // память для массивов фиксированного размера и обычных переменных
    // выделяется из специального резервуара памяти - стека;
    // стек имеет довольно ограниченный объем

    {
//        int arr[1000000000];  // 1 млрд. int-ов = 4 млрд. байтов памяти (стек такое не вместит)
    }

    // проблема нехватки памяти на стеке решается при помощи динамической памяти;
    // динамические выделение памяти - способ запроса памяти из операционной системы,
    // такая память выделяется из другого гораздо более объемного источника - кучи (heap)

    {
        // запросим выделение памяти для хранения целочисленного типа int
        // здесь используется оператор new
        // оператор new возвращает указатель, содержащий адрес выделенной памяти
        int *int_pointer = new int{0};  // инициализируем значение переменной нулем

        // для доступа (чтение, запись, удаление) к выделенной памяти используется указатель
        *int_pointer = 3;

        printf("Heap int variable address: %X, value: %d\n", int_pointer, *int_pointer);

        // стоит отметить, что указатель лежит на стеке, а не в куче,
        // т.е. после выхода из области видимости (scope) переменная-указатель
        // автоматически удалится из памяти, а вот данные на которые указатель ссылался - нет
        // поэтому необходимо вручную освободить выделенный участок памяти при помощи оператора delete

        delete /* указатель */ int_pointer;

        // даже если мы высвободили участок памяти (теперь он не в нашем владении)
        // требуется обнулить указатель, так как он все еще хранит в себе адрес высвобожденного участка памяти

        /*
         // попытка получить доступ к участку памяти, не принадлежащего нашей программе
         if (int_pointer != nullptr) {
            *int_pointer = 1;  // сработает и приведет к непредсказуемым результатам
         }

         // или попытка высвободить память повторно
         delete int_pointer;  // непредсказуемые результаты (скорее всего ошибка и завершение программы)
        */

        int_pointer = nullptr;  // обнуляем указатель

        if (int_pointer != nullptr) {  // уже не сработает
            *int_pointer = 1;
        }

        // оператор delete ничего не делает при работе с нулевыми указателями
        delete int_pointer;  // ничего не сделает
    }

    {
        // выделили памят из кучи и не высвобождаем ее
        int *int_pointer = new int{0};
    }
    // приводит к утечке памяти - программа владеет участком памяти, адреса к которой у нас уже нет

    return 0;
}