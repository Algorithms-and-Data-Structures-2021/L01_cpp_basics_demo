#include <iostream>  // cout
#include <array>     // array

using namespace std;

int main() {

    // массив - это тип данных, который хранит
    // набор последовательных элементов одного типа
    // [5, 2, 7, 1, 9] - набор последовательно расположенных в памяти чисел одного типа

    // создание статического (фиксированного размера) массива
    /* тип элементов */ int /* название массива */ int_arr[/* размер */ 5];

    // поэлементаная инициализация
    // для доступа к элементам массива используется оператор []

    // индексация начинается с 0
    int_arr[/* индекс элемента*/ 0] = /* значение */ -1;
    int_arr[1] = 9;
    int_arr[2] = 1;
    int_arr[3] = 5;
    int_arr[4] = 3;

    // инициализация массива в момент создания
    int int_arr2[] = {1, 4, 2};         // без указания размера (размер вычисляется автоматически)
    int int_arr3[5] = {1, 4, 2, 5, 7};  // с указанием размера

    // доступ к элементам массива
    int arr_element = int_arr[/* индекс элемента */0];

    cout << "Array element #0: " << arr_element << endl;

    // обращение к элементу за пределами массива не вызывает ошибку
    // возвращается "мусор" - данные где-то в памяти (будьте внимательны!)
    cout << "Array element #100: " << int_arr[100] << endl;

    // работа с массивами в цикле
    for (int index = 0; index < 5; index++) {
        if (int_arr[index] <= 0) {
            continue;  // пропускаем неположительные элементы
        }

        if (index == 3) {
            cout << "Processing the 3rd element of the array ..." << endl;
        }

        int_arr[index] *= 2;  // умножаем элементы массива на 2 и сохраняем
    }

    // for-each цикл без использования индекса для обращения к элементам массива
    for (int element : int_arr) {  // каждую итерацию в переменную element копируется следуюшее значение элемента массива
        cout << element << endl;
    }

    // проблема с такими массивами в том, что мы не можем узнать их размер
    // обычно, чтобы с этим как-то работать, вместе с массивами создают переменные, указывающие на размер массива,
    // что весьма неудобно и вызывает кучу ошибок в коде
    /**
     * Пример кода с переменной, обозначающей размер массива
     * int N = 10;
     * int arr [N];
     */

    // поэтому в современном C++ используется std::array - класс-оболочка обычных массивов
    // он хранит в себе размер массива, который можно получить при промощи вызова метода size()

    array</* тип элементов */int, /* размер */ 5> cpp_int_arr = {1, 3, 5, -1, 9};

    // доступ к элементам осуществляется через оператор [] или методом at(index)
    cpp_int_arr[0] = 1;
    cpp_int_arr[3] = 2;
    cpp_int_arr.at(2) = 3;

    // обращение к элементу через оператор [] за пределами массива не вызывает ошибку
    // возвращается "мусор" - данные где-то в памяти (будьте внимательны!)
    cout << "Array element (cpp) #100: " << cpp_int_arr[100] << endl;

    // вывод значения за пределами массива вызывает ошибку при использовании метода at(index)
    // метод at(index) проверяет индекс на выход за пределы массива и может выбросить ошибку
//    cout << "Array element (cpp) #100: " << cpp_int_arr.at(100) << endl;  // <-- раскомментируйте

    // получение размера C++ массива
    // метод size() класса array, вызов метода осуществляется через оператор . (точка)
    int cpp_arr_length = cpp_int_arr.size();

    // работа с C++ массивом в цикле (ничем не отличается от обычного массива)
    for (int index = 0; index < cpp_arr_length; index++) {
        if (cpp_int_arr[index] <= 0) {
            continue;  // пропускаем отрицательные элементы
        }

        if (index == 3) {
            cout << "Processing the 3rd element of the array ..." << endl;
        }

        cpp_int_arr[index] *= -1;  // умножаем элементы массива на -1 и сохраняем
    }

    // for-each цикл
    for (int element : cpp_int_arr) {
        cout << element << endl;
    }

    // передача массива в функцию
    // многомерные статические массивы

    return 0;
}
